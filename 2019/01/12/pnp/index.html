<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Yarn Plug&#39;n&#39;Play | linrz</title>
    <meta name="description" content="">
    
    
    <link rel="preload" href="/assets/css/0.styles.08bdfdef.css" as="style"><link rel="preload" href="/assets/js/app.6cecd588.js" as="script"><link rel="preload" href="/assets/js/3.44ff7866.js" as="script"><link rel="preload" href="/assets/js/1.cd6517b5.js" as="script"><link rel="preload" href="/assets/js/12.f22de79b.js" as="script"><link rel="preload" href="/assets/js/5.5d81cbfa.js" as="script"><link rel="prefetch" href="/assets/js/10.3da0edda.js"><link rel="prefetch" href="/assets/js/11.c078216b.js"><link rel="prefetch" href="/assets/js/13.531002c6.js"><link rel="prefetch" href="/assets/js/14.1537f746.js"><link rel="prefetch" href="/assets/js/15.d0895eff.js"><link rel="prefetch" href="/assets/js/16.5848278d.js"><link rel="prefetch" href="/assets/js/17.69773d0e.js"><link rel="prefetch" href="/assets/js/18.ce78b8fa.js"><link rel="prefetch" href="/assets/js/4.3cf70c88.js"><link rel="prefetch" href="/assets/js/6.859179a3.js"><link rel="prefetch" href="/assets/js/7.4a4405be.js"><link rel="prefetch" href="/assets/js/8.bd3aa100.js"><link rel="prefetch" href="/assets/js/9.b07964bf.js">
    <link rel="stylesheet" href="/assets/css/0.styles.08bdfdef.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div><div class="cute-nav"><div class="cute-nav-left"><a href="/">linrz</a></div> <div class="cute-nav-right"><div class="cute-nav-item cute-nav-active"><a href="/">Blog</a></div><div class="cute-nav-item "><a href="/about">About</a></div></div></div> <div class="cute-content"><div class="cute-page-header"><div class="cute-page-title">Yarn Plug'n'Play</div> <div class="cute-page-subtitle"><span class="cute-page-date">01/12 2019</span> <span>☕️</span> <span>4 min read</span></div></div> <div class="cute-page-markdown"><div slot="default" class="markdown-body content default"><h2 id="前言"><a href="#前言" class="header-anchor">#</a> 前言</h2> <p>yarn@1.11 版本中引入了 -pnp 参数，宣告彻底抛弃 node_modules 的一种解决方案 😎 ，pnp = Plug'n'Play = Plug and Play，意为可插拔的意思，是 yarn 在18年11月份时接受的<a href="https://github.com/yarnpkg/rfcs/pull/101" target="_blank" rel="noopener noreferrer">101号 RFC 提案<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，目的在于解决安装依赖的耗时瓶颈，系统的 I/O 时间，我们知道无论是 npm 还是 yarn 亦或是其他的包管理工具，都具备缓存的功能，大多数情况下安装依赖时，其实是将缓存中的相关包复制到项目目录中 node_modules 里。 yarn -pnp 的本质就是为了优化这关键的一步操作，在详细介绍之前，先了解下社区其他的解决方案。</p> <h2 id="pnpm"><a href="#pnpm" class="header-anchor">#</a> pnpm</h2> <p><a href="https://pnpm.js.org/" target="_blank" rel="noopener noreferrer">pnpm<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 通过 Hard links（硬链接） 和 symlinks（符号链接） 确保每个不同的包在你的电脑上只会有一个，不会占用额外的存储空间。 Hard links 相当于源文件的副本，但不占用任何空间，sysmlink 可以理解为快捷方式。但这种方式仍然有一些问题，改变硬链接的文件，相当于对源文件进行改变，可能会影响到其他使用这个源文件缓存的项目，另外 Node.js 也无法知道依赖是否通过其他方式比如 yarn link 创建了符号链接。对跨不同文件系统，如 NTFS 与 FAT32 互相操作，无法创建硬链接。最重要的，pnpm 并未减少系统 I/O 操作带来的时间。</p> <h2 id="tink"><a href="#tink" class="header-anchor">#</a> tink</h2> <p><a href="https://github.com/npm/tink" target="_blank" rel="noopener noreferrer">tink<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 和 pnp 差不多同时推出的解决方案，号称下一代包管理器，新增了 package-map.json 映射依赖对应的全局缓存中的路径，但如 README 所说，目前仍然处于开发阶段，不建议大家使用。粗略的看下源码，其思想是对 Node.js 的一些系统层面的 API 如 fs, child_process, module 等模块进行了 override 的操作，这样再寻找依赖时会遵循 tink 制定的规范。</p> <h2 id="pnp"><a href="#pnp" class="header-anchor">#</a> pnp</h2> <p>pnp 出现的原因主要有两点，第一，当我们 require 一个依赖时，Node.js 只是简单的递归去寻找 node_modules 中对应的包，直到找到匹配的包，如果未找到也不会立刻抛出异常，只在运行时才会发现。第二，是开篇一直提到的，从缓存中复制依赖到项目中的 node_modules 的 I/O 耗时难以优化。pnp的解决方案是彻底抛弃了node_modules，通过一个特殊的模块解析 resolver，将 require 的依赖，指向全局缓存中对应的包，这样可以直接略过 I/O 操作，减少安装依赖的耗时。</p> <p>深入学习下 pnp 详细的做法，在执行 yarn -pnp 时，会生成 .pnp.js 的文件，举个栗子，我们依赖 lodash ，.pnp.js 里会生成关于 lodash 的映射关系，如下图，将依赖路径映射到全局的目录下。
<img src="http://img.lastwhisper.cn/pnp-map.png" alt="pnp-map"></p> <p>但在实际使用时需要 preload .pnp.js 文件 。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// test.js</span>
<span class="token keyword">const</span> lodash <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'lodash'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><div class="language-shell extra-class"><pre class="language-shell"><code>node -r ./.pnp.js test.js
</code></pre></div><p>因为这个文件对 Node.js 的 Module 模块做了 monkey patch，修改了如 _load, _resolve , _findPath 等方法等来实现它特殊的依赖 resolver，想了解更多的话，直接 yarn -pnp 到生成的文件里看看究竟，但目前这个机制还是有些可以再改进的细节，比如映射关系是不是用类似 webpack 的 manifest 文件来表示更好，在 yarnrfc 里已有这个提案，希望不久的将来可以实现。</p> <p>在满缓存的情况下对普通的 yarn 和 yarn -pnp 做一次 benchmark。</p> <p><img src="http://img.lastwhisper.cn/yarn-normal.png" alt="yarn-normal"> <img src="http://img.lastwhisper.cn/yarn-pnp.png" alt="pnp"></p> <p>我们可以看到，显著的安装时间减少，除此之外，在未安装一些依赖时也无需等到运行时才会发现，预加载 .pnp.js 时会直接抛错提示开发者。虽然去年11月 Facebook 内部已经开始使用了 pnp 并且没有任何问题，但仍然不推荐在生产环境使用。CI 系统上可以先行试用，可以极大的减少安装依赖的时间。</p> <p>Yarn Plug'n'Play is future. Let's wait and see ! 🍺</p></div></div> <div class="cute-share">
  Share via
  <div class="cute-share-icon"><i class="iconfont icon-weibo"></i></div><div class="cute-share-icon"><i class="iconfont icon-twitter"></i></div><div class="cute-share-icon"><i class="iconfont icon-wechat"></i></div><div class="cute-share-icon"><i class="iconfont icon-download"></i></div> <div class="van-overlay" style="z-index:1;display:none;"><div class="cute-qrcode-container"><div class="cute-qrcode-inner"><div class="cute-qrcode-title">微信扫一扫，右上角分享</div> <div value="" level="L" background="#fff" foreground="#000"><canvas height="200" width="200" style="width:200px;height:200px;"></canvas></div></div></div></div></div></div> <div class="cute-footer cute-content"><div class="cute-footer-copyright">
    © linrz Themed By <a target="_blank" href="https://github.com/linrz/vuepress-theme-cute">vuepress-theme-cute</a></div> <div class="cute-footer-hills"></div></div></div><div class="global-ui"><!----></div></div>
    <script src="/assets/js/app.6cecd588.js" defer></script><script src="/assets/js/3.44ff7866.js" defer></script><script src="/assets/js/1.cd6517b5.js" defer></script><script src="/assets/js/12.f22de79b.js" defer></script><script src="/assets/js/5.5d81cbfa.js" defer></script>
  </body>
</html>
