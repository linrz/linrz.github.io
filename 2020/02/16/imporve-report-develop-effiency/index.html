<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>持续提升报表页面开发效率的实践 | linrz</title>
    <meta name="description" content="">
    
    
    <link rel="preload" href="/assets/css/0.styles.b6c88d7e.css" as="style"><link rel="preload" href="/assets/js/app.05ce796f.js" as="script"><link rel="preload" href="/assets/js/3.da47f26e.js" as="script"><link rel="preload" href="/assets/js/1.433bbcc0.js" as="script"><link rel="preload" href="/assets/js/11.1ccfc468.js" as="script"><link rel="preload" href="/assets/js/5.c05f2c91.js" as="script"><link rel="prefetch" href="/assets/js/10.46e46a9d.js"><link rel="prefetch" href="/assets/js/12.1fc06e96.js"><link rel="prefetch" href="/assets/js/13.9bc9143a.js"><link rel="prefetch" href="/assets/js/14.4fe684df.js"><link rel="prefetch" href="/assets/js/15.965ad640.js"><link rel="prefetch" href="/assets/js/16.e3875ece.js"><link rel="prefetch" href="/assets/js/17.9e786e39.js"><link rel="prefetch" href="/assets/js/18.0815a700.js"><link rel="prefetch" href="/assets/js/19.2801435f.js"><link rel="prefetch" href="/assets/js/4.aec11401.js"><link rel="prefetch" href="/assets/js/6.859179a3.js"><link rel="prefetch" href="/assets/js/7.6b2711ef.js"><link rel="prefetch" href="/assets/js/8.5a684bcc.js"><link rel="prefetch" href="/assets/js/9.88f9e6be.js">
    <link rel="stylesheet" href="/assets/css/0.styles.b6c88d7e.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div><div class="cute-nav"><div class="cute-nav-left"><a href="/">linrz</a></div> <div class="cute-nav-right"><div class="cute-nav-item cute-nav-active"><a href="/">Blog</a></div><div class="cute-nav-item "><a href="/about.html">About</a></div></div></div> <div class="cute-content"><div class="cute-page-header"><div class="cute-page-title">持续提升报表页面开发效率的实践</div> <div class="cute-page-subtitle"><span class="cute-page-date">02/16 2020</span> <span>☕️</span><span>☕️</span><span>☕️</span> <span>15 min read</span></div></div> <div class="cute-page-markdown"><div slot="default" class="markdown-body content default"><p>目前笔者主要负责商家的财务核算业务线，平时开发迭代中存在大量的财务报表，核算报表诸如此类大同小异的筛选项和列表组件组装的页面。如何提高开发效率，解放自己让自己有更多的时间去<s>摸鱼</s>（升级前端依赖）是一件不可避免的事儿。</p> <p>一张常见的报表页面如下图所示，一二级菜单及侧边栏可忽略，属于容器的部分。业务页面只会挂在中间这块锚点上。</p> <p><img src="http://img.lastwhisper.cn/common-report.png" alt="http://img.lastwhisper.cn/common-report.png"></p> <p>一开始刚拿到这种类型的页面时，在基础组件库 <a href="https://github.com/youzan/zent" target="_blank" rel="noopener noreferrer">zent<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 的支持下粗略的估了下开发量约 12个小时（1.5天），整个页面结构看似简单，包含的功能如下</p> <ul><li>根据各筛选条件查询数据在列表中展示</li> <li>分页触发筛选对应页码的数据</li> <li>每个筛选项的细节处理，如异步加载数据等等</li> <li>由于其他页面可能会携带参数跳转过来以及筛选项较多防止用户误刷新需要重新选择筛选条件，需要将上一次查询条件保存在 url 上，需要从 url 上还原筛选条件</li> <li>导出触发筛选条件确认弹窗和是否需要密码等输入的数据传递给后端</li> <li>清空筛选条件时还原为默认值</li> <li>触发筛选时筛选按钮和列表同时 loading 防止用户继续操作</li> <li>列表中数据没有返回值时需要展示对应的默认值如 ”-“</li> <li>有的列数据需要作枚举转换如单据状态，金额转换，链接形式展示，分行展示，过长时需要 hover 气泡展示完整的</li> <li>可能会根据筛选项中勾选的维度展示对应的一列或多列</li> <li>操作栏可能会有多个链接式的展示，点击弹出气泡/对话框，完成删除或更新等操作在回调中刷新列表或者携带数据跳转等</li></ul> <p>在经过多个项目类似这种页面的洗礼后，我们开始思考怎么提高开发效率 🤔</p> <p>第一阶段，在基础组件库的支持下，我们在上面继续抽象业务组件，重复的开发量主要集中在：</p> <ol><li>列表组件的分页触发时的 <code>onChange</code> 逻辑</li> <li>列表组件展示涉及到一系列转换</li> <li>表单组件操作栏时的 <code>onSubmit</code> 、<code>onClear</code> 等逻辑</li> <li>一些可共用的 FormField 组件</li></ol> <p>对于 1 和 3，我们和后端约定，筛选请求的入参结构一定是平铺的，返回结构一定是标准的分页结构。基于这个约定，我们可以做到封装一个组件使其传入接口请求的地址即可完成提交和翻页的动作。由于基础组件库列表组件有几种不同的表现形式，我们称之为 Table 组件和 Grid 组件，虽然功能大同小异，为了更加灵活，我们不根据 props 决定列表用哪个组件，避免后续增加需要改动该组件和适配不同的逻辑，列表组件由外部作为 children 组件传入。所以我们产出了一个 HOC 组件，它负责渲染 children 组件和拦截分页和筛选触发的事件逻辑，接管应该有的 loading，列表数据等内置状态，当然外部传入方法可以覆盖掉它的内部处理。</p> <p>对于 2，转换的场景大致有金额转换、枚举值转换成文字、同一格多行展示、一格放不下使用气泡 hover 展示、表头增加提示图标，hover 展示对该列的解释、表头的排序图标点击触发排序、不同的店铺类型和员工角色部分列看不到...，针对这些过多耦合了业务场景的功能，我们产出了一个 adapter 专门去做这些事儿，基础组件库的列表组件的 column props 只支持 <code>title</code>, <code>name</code>, <code>render</code>, <code>textAlign</code> 等基础的熟悉，我们在上面扩展了 <code>isMoney</code>, <code>enumMap</code>, <code>titleDesc</code>, <code>multipeLines</code>, <code>hoverCamplines</code>, <code>needSort</code>, <code>hideOn</code> 等抽象过的配置，经过 adapter 再转换成基础组件支持的配置。</p> <p>对于 4，我们期望能有一个 Field 中心的概念，我们只需从这个地方 import 所需的业务 Field，每种 Field 接收的 value 数据结构和 onChange 出去的数据结构是约定好的，比如时间筛选是 <code>Array&lt;Date&gt;</code>， 下拉框是 <code>{ text: string, value: any, ...可能携带的额外扩展字段 }</code>，复选框是 <code>Array&lt;复选框对应的 value &gt;</code>去组装下排列即可。</p> <p>经过一段时间验证后，报表页面的开发工作量已经降到了8小时以下了，我们发现不同业务线都需要把列表的数据导出成 Excel 方便用户查看，数据量大时在页面上一页页翻实在是太痛苦了。各业务线的导出任务框架和模型在初期并不统一，各自实现了一套。UI 上也是大同小异，需要弹窗一个弹窗给用户二次确认导出的筛选条件并选择 Excel 的打开是否需要密码，因此在第二阶段，我们着重把导出的逻辑与筛选组件解耦，在统一的组件中维护导出的逻辑，与后端约定导出涉及到的接口规范，因为需要在查看导出列表时方便的看到当时操作的筛选条件，所以我们会把当前筛选项的结构排列也传过去，后端在查看接口再回传给我们。大概格式如 <code>{ exportParams: Array&lt;FieldItem&gt;, filterParams: Dictionary }</code>，具体的实现还是基于 HOC，给筛选组件套上一层 HOC，注入导出的逻辑，不得不承认HOC 在属性代理这块太好用了，可能你会疑惑为什么不用 hooks 去做呢，其一是当时 hooks 没有推出来，其二是觉得通过 HOC 可以隐式的完成生成 props 这一动作，而 hooks 对于生产和消费都要主动的去调用，最常见的 useState 也是需要主动将 value 传递到某个组件，另外可能有后续的迭代中是不仅基于导出这个场景扩展到对筛选组件有些视图上的改变，hooks 就可能不太合适了。</p> <p>这样，我们的开发工作量又下降了两个小时左右，但是还是达不到快速生成报表页面这一“快速”的理想，我们期望工作量可以降到 2h 左右，以个人拙见可以继续优化的方向有三个：</p> <ol><li>更大更抽象的业务组件，页面级的组件</li> <li>CLI 快速生成一套通用的模板代码进行修改</li> <li>通过 DSL 语言描述去组装页面</li></ol> <p>第一点页面级组件的想法，我觉得初期会很方便，但在持续迭代的过程中，props 会越来越多，对组件的一个小改动，我们需要去全量回归它的其他功能是否被影响到，不可避免的还会有一些其他的特殊需求，产品经理就想加这个改动，但它又不是通用的。怎么办呢只能继续加 props 加 if 判断，到后面越来越臃肿越来越庞大。</p> <p>第二点其实是个很灵活的方向，一次编写，多次生成，但是仓库中重复的代码会很多，基础组件有些改动需要多个地方同时修改，不幸有 bug 的话会被放大 N 倍。</p> <p>业界对第二第三点都有实践，比如 umi block 和云凤蝶，通过 DSL 语言去组装页面，再通过后台拖拖拽拽去生成 DSL 描述，乍一看觉得前景很美好，效率很高。但我觉得也还是需要做好权衡，因为增加了学习成本和开发成本，开发一套配置后台的成本并不低，DSL 语言约定的各个字段代表的意思和非编程语言带来的不灵活也会带来一定的困扰。</p> <p>基于这几点考虑，我们最终还是选择了第三个方向，在开始做的时候我也产生了深深的怀疑，真的可以提高效率吗，到最后会不会因为 10% 的特殊需求反而将整个页面重构成原来用 JS 写的呢。因此在开始前也做了大量的调研包括业界比较著名的云凤蝶等，我拜读过这个问题下的所有回答，<a href="https://www.zhihu.com/question/315298251/answer/626911758" target="_blank" rel="noopener noreferrer">有没有基于React、Antd自动生成CRUD的库和框架？<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>
，引用徐飞老师在这里的回答</p> <blockquote><p>每个存在大量 CRUD 系统的公司都值得去做一下。但是这个事情是很考验水平的，因为本质上是要把代码配置化，而且不是单个表单的配置化，而是整个简单业务。</p></blockquote> <p>虽然拿捏不准，也没有很多额外的业余之外的时间，我还是开始尝试了，这里 DSL 语言我们选用最常见的 JSON 去描述，要实现通过解析 JSON 去组装组件拼装成页面有三个重要的点，一个是 DSL 语言的字段描述，一个是可配置的组件，最重要的是组件的状态外置用于解决状态共享和联动问题。</p> <p>JSON 的字段描述暂时不过多赘述，本质上只是起到约束和解析的作用，可配置的组件我觉得可以再细分三类：基础组件，业务组件，外部组件。我们需要根据业务场景对接常用的基础组件，抽象出一层通用的动作，业务组件大多数已经抽象了一层，除了联动的一些场景外不太需要做过多的准备，外部组件我们期望可以利用 NPM 的生态，直接指定某个外部包导入过来注册成组件，外部组件可能会有些各种各样的问题因为不在制定业务的体系下，比如重复的依赖啊等等。为了组件的状态外置我们需要状态管理工具帮我们解决，这里我考虑过 redux、mobx 等常见的流行库，但最终选择了 unstated，我觉得 unstated 可能是 react 生态下最好用的状态管理工具。redux 过于复杂，为了解决异步的副作用还得引入 thunk 或者 saga 或者自己写中间件，mobx 的理念不太适合 react 的体系。unstated 中的 container 这种发布订阅的模式比较适合配置组装的这种场景，试想一下我们并不知道页面长什么样它们之前怎么联动，但是数据源的来源是固定的，无非是固定的入参亦或从 url 上解析 param 或者基于页面上的状态去请求后端接口。每个组件或者每几个组件有个封装好的 container，container 中包含了组件所需要的状态和 action，我们只需要在配置后台把几个组件间的联动关系通过勾选的方式给联系起来，比如按钮需要的 onClick 和筛选组件的 container 的 onSubmit 方法绑定，某个下拉框中的 value 和某个 container 中的 state 绑定。亦或内置的这些 container 中的方法满足不了你的需求，可以自定义 container，指定组件去订阅你的 container 或者两者做一个 mixin 减少重复代码的编写。举个例子，比如列表中的操作栏有个删除按钮，虽然点击删除后的动作也是可以枚举的，比如打开弹窗，弹出气泡亦或直接发请求等等，这些通用可以枚举的场景我们可以内置好，通过制定的配置字段去描述，但是避免不了有些额外的逻辑，比如后端说这个动作涉及到的数据量太大，不能同步返回结构，需要走异步前端再轮询去查确定是成功还是失败。面对这种难以用配置去描述的需求，大多数市面上的配置生成的工具都不会选择去完成这个功能，但是我们需要，我们的业务有的报表不是简单的展示，确实有一些复杂的前端逻辑在里面，所以我觉得这块的灵活性我也着重关注。</p> <p>在这些思路的背景下，<code>cube</code> 诞生了，我给它的定位是“提供组装可配置组件的能力”，它的使命和愿景是“90%的配置 + 10%的胶水代码完成标准化设计的业务需求”。因为关注 10% 特殊需求的灵活性，避免因为后续迭代中 10% 的特殊需求无法完成而重构整个页面，所以需要手写部分代码，还是刚才上面说的删除这个场景，我的解决方案是，操作栏使用自定义组件这个概念，解析 JSON 时会去懒加载对应的涉及到的组件和你注册的自定义组件，在配置中声明订阅列表组件的 container，这样列表的状态和方法开发者完全可以任意掌控，甚至所有的 container 都继承了我定义的一个 BaseContainer，BaseContainer 中实现了任意 setState 的方法可以给开发者去调用，虽然这样会造成数据流混乱，但我觉得他在灵活这方面收益是远大于数据流混乱带来的风险的。 <code>cube</code> 所做的工作在这里简单描述下，首先会去递归的解析 JSON，这里的解析是自底向上的去遍历是深度优先的，因为 JSX 被 babel 转过后的 React.createElement 本身也是自底向上的。然后会根据解析出来的每个组件的配置单元去匹配组件简称 <code>getComponentByType</code> 方法，找到对应的组件后会根据是否有内置的 container 或者外部指定的 <code>containerKey</code> 去寻找对应的 container 在 unstated 中的 provider 中去注入让组件订阅。这几个步骤依次执行完后，整个页面需要的组件已被组装好，React 会帮助我们在 DOM 中给渲染出来。</p> <p>剩下的就是 JSON 的存储和获取，配置后台中的可视化操作如何去生成或修改 JSON 的配套工作了，目前运用这套方案辐射的业务还是有限的几个场景，笔者希望后续在其他业务线可以收集到更多的使用场景去完善配置化的方案。</p></div></div> <div class="cute-share">
  Share via
  <div class="cute-share-icon"><i class="iconfont icon-weibo"></i></div><div class="cute-share-icon"><i class="iconfont icon-twitter"></i></div><div class="cute-share-icon"><i class="iconfont icon-wechat"></i></div><div class="cute-share-icon"><i class="iconfont icon-download"></i></div> <div class="van-overlay" style="z-index:1;display:none;"><div class="cute-qrcode-container"><div class="cute-qrcode-inner"><div class="cute-qrcode-title">微信扫一扫，右上角分享</div> <div value="" level="L" background="#fff" foreground="#000"><canvas height="200" width="200" style="width:200px;height:200px;"></canvas></div></div></div></div></div></div> <div class="cute-footer cute-content"><div class="cute-footer-copyright">
    © linrz Themed By <a target="_blank" href="https://github.com/linrz/vuepress-theme-cute">vuepress-theme-cute</a></div> <div class="cute-footer-hills"></div></div></div><div class="global-ui"><!----></div></div>
    <script src="/assets/js/app.05ce796f.js" defer></script><script src="/assets/js/3.da47f26e.js" defer></script><script src="/assets/js/1.433bbcc0.js" defer></script><script src="/assets/js/11.1ccfc468.js" defer></script><script src="/assets/js/5.c05f2c91.js" defer></script>
  </body>
</html>
