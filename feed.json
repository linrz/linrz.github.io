{
    "version": "https://jsonfeed.org/version/1",
    "title": "linrz",
    "home_page_url": "linrz.me",
    "feed_url": "linrz.me/feed.json",
    "items": [
        {
            "id": "linrz.me/2019/09/16/a-coincidence-bug/",
            "url": "linrz.me/2019/09/16/a-coincidence-bug/",
            "title": "一个机缘巧合的 bug",
            "summary": "中秋节前的最后一个工作日的晚上，同事突然和我说有个 css 文件打包完没传到 cdn 上去，其他 js css 文件都自动传上去了。\n有点震惊，第一反应是打包机器上没生成这个文件，细看了下打包日志是有的，登到机器上也是有这个 css 文件的，\n一路跟踪到 cdn 的包发现把这个 css 文件识别为了 video/mp2t 类型的文件了，和后缀名不一样阻止了上传。",
            "image": "http://img.lastwhisper.cn/file-code.png",
            "date_modified": "2019-09-16T15:50:00.000Z"
        },
        {
            "id": "linrz.me/2017/11/05/fastify/",
            "url": "linrz.me/2017/11/05/fastify/",
            "title": "Fastify",
            "summary": "`",
            "image": "http://img.lastwhisper.cn/fastify-benchmark.png",
            "date_modified": "2017-11-05T12:00:00.000Z"
        },
        {
            "id": "linrz.me/2019/01/12/pnp/",
            "url": "linrz.me/2019/01/12/pnp/",
            "title": "Yarn Plug'n'Play",
            "summary": "tink 和 pnp 差不多同时推出的解决方案，号称下一代包管理器，新增了 package-map.json 映射依赖对应的全局缓存中的路径，但如 README 所说，目前仍然处于开发阶段，不建议大家使用。粗略的看下源码，其思想是对 Node.js 的一些系统层面的 API 如 fs, child_process, module 等模块进行了 override 的操作，这样再寻找依赖时会遵循 tink 制定的规范。",
            "image": "http://img.lastwhisper.cn/pnp-map.png",
            "date_modified": "2019-01-12T12:00:00.000Z"
        },
        {
            "id": "linrz.me/2019/03/21/berry/",
            "url": "linrz.me/2019/03/21/berry/",
            "title": "yarn@berry",
            "summary": "不需要在 \b\bpackage.json 的 scripts 中使用类似 cross_env 的命令了，yarn 会默认使用一个轻量级的支持 POSIX 标准的\b shell。",
            "date_modified": "2019-03-20T19:30:00.000Z"
        },
        {
            "id": "linrz.me/2018/05/15/why-i-unlike-styled-components/",
            "url": "linrz.me/2018/05/15/why-i-unlike-styled-components/",
            "title": "为什么我不喜欢 styled-components",
            "image": "http://img.lastwhisper.cn/styled-components-render.png",
            "date_modified": "2018-05-14T20:00:00.000Z"
        },
        {
            "id": "linrz.me/2019/08/09/mac-apps-i-used/",
            "url": "linrz.me/2019/08/09/mac-apps-i-used/",
            "title": "我常用的 MacOS Application",
            "summary": "决定写点啥打发些许时间，舒缓下积压很久的内心，重新启动一下博客，水一篇不用动脑子的文章摸一下鱼。如果对看客有一点点帮助，那就是极好的了，或许我的品位也正好处于你的鄙视链底端，那就笑一笑。",
            "date_modified": "2019-08-08T20:00:00.000Z"
        },
        {
            "id": "linrz.me/2019/11/11/the-future-of-javascript-package-managment/",
            "url": "linrz.me/2019/11/11/the-future-of-javascript-package-managment/",
            "title": "The future of JavaScript package managment",
            "summary": "某些情况依赖提升也是件恶心的事情，举个栗子，我的项目依赖 a b c，a 和 b 依赖 react@15，c 依赖 react@16，项目里 react@15 会被提升到 nodemodules 第一层级，react@16 在 c 的 nodemodules 里，但是如果项目本身依赖 react@16，16则会被提升到 nodemodules 第一层级，15 则分别在 a 和 b 的 nodemodules 里各持有一份，重复占用了空间。归根结底还是 Node.js resolve 策略的问题，曾有人提出是否可以支持自定义 自定义 resolve 策略 ，比如像 Java 的 Maven 一样，全局共用依赖，意图减少空间和 resolve 的查找复杂度，遗憾的是 sindresorhus 回复 module resolutio 提案已进入 lock 阶段。无法在 Node.js 支持掉，各大前端基础工具经过这几年的发展都开发了自己的 resolve 工具，比如 webpack 的 enhanced-resolve，Babel/Jest/Prettier 使用的 resolve 等等，想规避掉层层查找 node_module 带来的复杂度和问题。",
            "image": "http://img.lastwhisper.cn/WechatIMG101.png",
            "date_modified": "2019-11-10T17:00:00.000Z"
        }
    ]
}