(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{231:function(t,e,n){"use strict";n.r(e);var a=n(39),o=Object(a.a)({},(function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("p",[t._v("页面配置生成这个事情，引用徐飞老师曾经在知乎的回答")]),t._v(" "),n("blockquote",[n("p",[t._v("每个存在大量 CRUD 系统的公司都值得去做一下。但是这个事情是很考验水平的，因为本质上是要把代码配置化，而且不是单个表单的配置化，而是整个简单业务。")])]),t._v(" "),n("p",[t._v("在目前公司的业务上主要是表现在筛选和列表组合的页面（整体技术栈是基于 React），在 ERP 业务中太多了。所以做这个事儿的初衷的首要目标提示这部分页面的开发效率，然后再慢慢辐射到其他业务线通用的业务上。")]),t._v(" "),n("p",[t._v("刚开始设计时，首要考虑的就是如何避免扩展性不够的问题。常见的 90% 需求都可以解决，剩下的 10% 需求需要花成倍的时间取解决，得不偿失，造成学习成本变高，预期降低，工作量收益变低。想象一下同事撸起袖子对我说本来可以抄起键盘一顿 comman + c 然后 command + v，改改接口名，改改数据格式就完成的事，用了你这个解决方案发现满足不需求还花了数倍的时间重构回去。")]),t._v(" "),n("p",[t._v("所以首先得把这种场景给咔嚓掉，可以发现配置化不能完全满足需求，但可以大部分配置渲染，少部分用自己写的组件渲染。举个栗子，列表中的操作栏有个删除按钮，点击向后端发起 DELETE 请求，完成后再刷新一遍列表，发起 GET 请求。这个动作也够通用，可以抽象成配置语言描述。但可能产品说，点击按钮时先弹个弹窗，让用户填下删除的备注原因。\n用配置项抽象这个动作有点难，复杂度也不低，这种情况我趋向于让开发者编写弹窗内的组件完成这个业务逻辑。我们赋予开发者获取列表和弹窗 store/action 的能力。点击打开弹窗这个动作足够通用，可以仍然由配置完成，打开弹窗后的事情由开发者自定义的组件接管。如果业务流程足够标准和通用，这个动作抽象成配置也是可以的，在起步阶段还是趋向于将控制权交给开发者较好。")]),t._v(" "),n("p",[t._v("状态管理是必须的，自定义组件需要有获取任意配置渲染组件的 store/action 的办法。Redux/Mobx/MST... 状态管理工具都可以满足我们的需求，这里我的出发点是用起来足够 easy 和贴近日常开发。由于是 React 技术栈，考量了一番还是选择了 Unstated 这个基于 context 库。Mobx 数据是 reactvie 的和团队的开发习惯有点偏离，使用 Redux 稍微有点麻烦，一个页面有使用了两个相同 Table 组件的列表，在单一 store 里怎么组织呢，当然解决也是可以解决的，和 unstated 比起来还是 unstated 更方便更轻量（源码不到两百行），并且 unstated-next 对 hooks 的支持更好。")]),t._v(" "),n("p",[t._v("本质来说，React 本身就是一个抽象语言，现在需要再用另一个抽象语言来抽象 React，解析成对应 React 组件，借助 React 的渲染能力完成最终页面展示。配置式的语言没有太多讨论必要，JSON 就足够了。在解析 JSON 的时候需不需要递归遍历呢？这个点思忖了良久，一开始时决定不去递归遍历，我的想法时这是不可控的，可能 Table 组件的 column 字段有 children，需要转换成对应组件渲染，可能 Dialog 组件 content 字段有 children 等等...所以更趋向于在像可配置的组件列表里添加新组件时，由配置平台的开发在新增组件比如 Dialog 组件时包裹一下，在内部加上解析 content 这个 props 的逻辑，调用将配置转换成组件的 factory 方法。实际上在配置平台用户拖拽的 Dialog 组件不是基础的组件，是包裹了一层的可配置的组件。")]),t._v(" "),n("p",[t._v("很快我发现不做递归遍历是个错误的抉择，举个栗子，一个自定义的按钮组件和一个配置渲染的列表组件。自定义的按钮组件想更改列表组件的状态，比如触发 loading。如果声明自定义按钮组件的配置放在列表组件配置的上方，由于 JSON 里各个字段也是按顺序解析的，在解析完按钮组件时，列表组件还为被解析，状态管理的池子里并没有列表相关的 store 和 action，在 unstated 里被称为 container。也就是说在渲染按钮时无法让这个按钮 去 subscribe 列表的 container，因为这时候还未生成列表的 container。所以暂时更改了解析策略，在匹配组件前先递归遍历一遍构建完整个配置中涉及到组件的 containers。")]),t._v(" "),n("p",[t._v("搞定完自定义组件开始思考整个配置的字段设计。现在的前后端协作开发工作中，大部分都是围绕将后端的字段映射到前端的组件中渲染这个核心开发的。联调的时候也是绕着这个团团转，我们能不能做到告诉后端这个页面的 Schema，设计给的 UI 页面对应我开发的组件结构是这样的，这个 date 字段是什么格式的时间戳还是 yyyy-mm-dd 的。削去前端的联调工作量，让后端对着我们给的 Schema 去联调？")]),t._v(" "),n("p",[t._v("下次找个时间再聊聊这个。")])])}),[],!1,null,null,null);e.default=o.exports}}]);